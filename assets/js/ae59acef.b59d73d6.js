"use strict";(self.webpackChunkthomascristofaro_learning=self.webpackChunkthomascristofaro_learning||[]).push([[1882],{909:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-4-42f2ca95dc3fbc35b97942faca073d38.png"},1956:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-example-design-f7fe2125b6e27b9102e90d883c23ac39.png"},7921:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-8-d63e78e9095ff3fde16a2d54c4c92850.png"},22943:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-6-e07ee86ba186e2cdbf8ee7ab5478356a.png"},28410:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"business-central/posting/exercise","title":"Designing a Squash Court app","description":"Link Codice Sorgente GitHub","source":"@site/docs/business-central/10-posting/02-exercise.md","sourceDirName":"business-central/10-posting","slug":"/business-central/posting/exercise","permalink":"/learning/docs/business-central/posting/exercise","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"Esercizio"},"sidebar":"businessCentralSidebar","previous":{"title":"Teoria","permalink":"/learning/docs/business-central/posting/theory"},"next":{"title":"API","permalink":"/learning/docs/category/api"}}');var o=i(74848),r=i(28453);const s={sidebar_label:"Esercizio"},t="Designing a Squash Court app",l={},d=[{value:"Analisi",id:"analisi",level:2},{value:"Fit-gap analysis",id:"fit-gap-analysis",level:4},{value:"Posting schema",id:"posting-schema",level:4},{value:"The Project approach",id:"the-project-approach",level:4},{value:"Relationship Management",id:"relationship-management",level:2},{value:"Processo di prenotazione",id:"processo-di-prenotazione",level:2},{value:"Struttura",id:"struttura",level:3},{value:"Squash Court",id:"squash-court",level:4},{value:"Journal Template",id:"journal-template",level:4},{value:"Journal Batch",id:"journal-batch",level:4},{value:"Register",id:"register",level:4},{value:"Journal Line",id:"journal-line",level:4},{value:"Time calculation",id:"time-calculation",level:4},{value:"Price Management",id:"price-management",level:4},{value:"Inherited data",id:"inherited-data",level:4},{value:"Posting process",id:"posting-process",level:3},{value:"Check line",id:"check-line",level:4},{value:"Post line",id:"post-line",level:4},{value:"Processo di fatturazione",id:"processo-di-fatturazione",level:2},{value:"Fattura",id:"fattura",level:3},{value:"Sales Header",id:"sales-header",level:4},{value:"Sales Line",id:"sales-line",level:4},{value:"Dialog",id:"dialog",level:4},{value:"Posting process",id:"posting-process-1",level:3},{value:"Trova Movimenti",id:"trova-movimenti",level:3},{value:"FindRecords",id:"findrecords",level:4},{value:"ShowRecords",id:"showrecords",level:4}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"designing-a-squash-court-app",children:"Designing a Squash Court app"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/thomascristofaro/its-bc-posting",children:"Link Codice Sorgente GitHub"})}),"\n",(0,o.jsxs)(n.p,{children:["Creiamo una struttura personalizzata in Microsoft Business Central. Gestiremo un'azienda che noleggia campi da squash. Per prima cosa dobbiamo definire le modifiche e le espansioni al prodotto, per farlo dobbiamo effettuare una ",(0,o.jsx)(n.strong,{children:"Fit-gap analysis"}),': esaminiamo i processi dell\'azienda e definiamo cosa possiamo e cosa non possiamo fare con il pacchetto standard. Quando un processo aziendale pu\xf2 essere gestito con il software standard, lo chiamiamo "aderente" (',(0,o.jsx)(n.strong,{children:"Fit"}),'). Quando non \xe8 possibile farlo, si tratta di uno "scostamento" (',(0,o.jsx)(n.strong,{children:"Gap"}),"), possiamo colmare un gap sviluppando una soluzione personalizzata o acquistando un componente aggiuntivo."]}),"\n",(0,o.jsx)(n.h2,{id:"analisi",children:"Analisi"}),"\n",(0,o.jsx)(n.h4,{id:"fit-gap-analysis",children:"Fit-gap analysis"}),"\n",(0,o.jsx)(n.p,{children:"Il processo di base di un'azienda che gestisce campi da squash consiste nel noleggio dei campi ai giocatori di squash, sia ai membri che ai non membri. Esiste un processo di prenotazione e fatturazione che gestisce tariffe diverse per i membri e i non membri."}),"\n",(0,o.jsx)(n.p,{children:'In Business Central, i dati master dei clienti e dei fornitori vengono gestiti utilizzando il "Relationship Management" (RM). Per la nostra soluzione, creeremo una nuova master table per i giocatori di squash e saranno integrati con il RM.'}),"\n",(0,o.jsx)(n.p,{children:'Per progettare la tabella "Squash Court", esamineremo la progettazione degli Item del pacchetto standard.\nLa "Squash Court" sar\xe0 il prodotto dell\'applicazione, con un journal per creare movimenti di prenotazione, che potremo poi fatturare. Per il processo di fatturazione, utilizzeremo e integreremo la parte delle vendite di Business Central.'}),"\n",(0,o.jsx)(n.h4,{id:"posting-schema",children:"Posting schema"}),"\n",(0,o.jsx)(n.p,{children:"Dopo aver deciso quale sar\xe0 il design della nostra applicazione, possiamo disegnare le tabelle e definire le procedure di registrazione. Questo ci guider\xe0 attraverso il processo di sviluppo."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Example Posting Schema",src:i(1956).A+"#center",width:"488",height:"312"})}),"\n",(0,o.jsx)(n.p,{children:"Gli oggetti in Relationship Management e Sales sono oggetti standard che potremmo dover modificare. Gli oggetti per l'applicazione di Squash sono nuovi, ma basati su oggetti simili dello standard."}),"\n",(0,o.jsx)(n.h4,{id:"the-project-approach",children:"The Project approach"}),"\n",(0,o.jsx)(n.p,{children:"Per tenere traccia del nostro progetto, suddivideremo le modifiche in task pi\xf9 piccole:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Modificare il Relationship Management: creare un giocatore di squash da un contatto."}),"\n",(0,o.jsx)(n.li,{children:"Processo di prenotazione di un campo da squash."}),"\n",(0,o.jsx)(n.li,{children:"Processo di fatturazione delle prenotazioni."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"relationship-management",children:"Relationship Management"}),"\n",(0,o.jsxs)(n.p,{children:["Dobbiamo avere la possibilit\xe0 di creare un giocatore di squash da un contatto proprio come avviene per un cliente o fornitore.\nCerchiamo di capire come funziona il metodo standard per la creazione e lo adattiamo al nostro caso d'uso.\nBisogna quindi analizzare la funzione che troviamo nella pagina ",(0,o.jsx)(n.code,{children:"Contact Card"})," chiamata ",(0,o.jsx)(n.code,{children:"CreateCustomer"})]}),"\n",(0,o.jsx)(n.p,{children:"Analizzando la funzione, vedremo che avremo bisogno di:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Squash Setup"}),": Squash Player Nos. e Squash Court Nos."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Squash Setup",src:i(22943).A+"",width:"615",height:"108"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Squash Player"}),' master table: prendiamo la esempi dalla tabella Contact perch\xe8 c\'\xe8 il transferfield + nel campo "Series No." aggiungere TableRelation con "Series No."']}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Squash Player",src:i(69142).A+"",width:"615",height:"345"})}),"\n",(0,o.jsx)(n.p,{children:"Aggiungere ora il codice per la gestione del numeratore:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'    field(_; "No."; Code[20])\n    {\n        trigger OnValidate();\n        begin\n            IF "No." <> xRec."No." THEN BEGIN\n                SquashSetup.GET;\n                NoSeriesMgt.TestManual(SquashSetup."Squash Player Nos.");\n                "No. Series" := \'\';\n            END;\n        end;\n    }\n\n    TRIGGER OnInsert()\n    BEGIN\n        IF "No." = \'\' THEN BEGIN\n            SquashSetup.GET;\n            SquashSetup.TESTFIELD("Squash Player Nos.");\n            NoSeriesMgt.InitSeries(SquashSetup."Squash Player Nos.", xRec."No. Series",0D,"No.","No. Series");\n        END;\n    END;\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Nella tabella ",(0,o.jsx)(n.code,{children:"Contact Business Relation"})," campo ",(0,o.jsx)(n.code,{children:"Link to Table"})," aggiungere ",(0,o.jsx)(n.code,{children:"Squash Player"})," + la TableRelation nel campo ",(0,o.jsx)(n.code,{children:"No."})]}),"\n",(0,o.jsxs)(n.li,{children:["Aggiungere il campo ",(0,o.jsx)(n.code,{children:"Bus. Rel. Code for Squash Player"})," in ",(0,o.jsx)(n.code,{children:"Marketing Setup"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Adesso possiamo sviluppare la funzione per creare il Player a partire dal contatto:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'// prendendo esempio dalla CreateCustomer\nprocedure CreateSquashPlayer()\nbegin\n    TESTFIELD(Type, Type::Person);\n    RMSetup.GET;\n    RMSetup.TESTFIELD("Bus. Rel. Code for Squash Pl.");\n    CLEAR(SquashPlayer);\n    SquashPlayer.INSERT(TRUE);\n\n    ContBusRel."Contact No." := Cont."No.";\n    ContBusRel."Business Relation Code" := RMSetup."Bus. Rel. Code for Squash Pl.";\n    ContBusRel."Link to Table" := ContBusRel."Link to Table"::"Squash Player";\n    ContBusRel."No." := SquashPlayer."No.";\n    ContBusRel.INSERT(TRUE);\n    \n    UpdateCustVendBank.UpdateSquashPlayer(Cont,ContBusRel);\n    MESSAGE(Text009,SquashPlayer.TABLECAPTION,SquashPlayer."No.");\nend;\n\n// prendendo esempio dalla UpdateCustomer\nprocedure UpdateSquashPlayer()\nbegin\n    WITH SquashPlayer DO BEGIN\n        GET(ContBusRel."No.");\n        xRecRef.GETTABLE(SquashPlayer);\n        NoSerie := "No. Series";\n        TRANSFERFIELDS(Cont);\n        "No." := ContBusRel."No.";\n        "No. Series" := NoSerie;\n        MODIFY;\n        RecRef.GETTABLE(SquashPlayer);\n        ChangeLogMgt.LogModification(RecRef,xRecRef);\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"processo-di-prenotazione",children:"Processo di prenotazione"}),"\n",(0,o.jsxs)(n.p,{children:["Per costruire un flusso di registrazione prenderemo esempio dalla gestione delle ",(0,o.jsx)(n.code,{children:"Resource"})," in Business Central, questo perch\xe8 le risorse hanno un processo semplice da capire come per gli item, ma a differenza di questi sono anche pi\xf9 semplici da utilizzare."]}),"\n",(0,o.jsx)(n.h3,{id:"struttura",children:"Struttura"}),"\n",(0,o.jsx)(n.h4,{id:"squash-court",children:"Squash Court"}),"\n",(0,o.jsx)(n.p,{children:"Questa tabella master \xe8 simile alle risorse, quindi possiamo andare a copiare le sue funzionalit\xe0.\nUtilizzeremo per\xf2 il numero di serie inserito nella Squash Setup."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Squash Court",src:i(53042).A+"",width:"615",height:"125"})}),"\n",(0,o.jsxs)(n.p,{children:["Come obiettivo dell'esercizio vogliamo essere in grado di tenere traccia delle prenotazioni.\nCreeremo quindi uno Squash Journal per creare movimenti di prenotazioni che potranno essere fatturati.\nUn journal ha bisogno di una struttura complessa, per questo la creeremo a partire da una gi\xe0 esistente. Copieremo quindi le ",(0,o.jsx)(n.code,{children:"Resource Journals"}),":"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Resource Journals",src:i(94912).A+"",width:"798",height:"454"})}),"\n",(0,o.jsx)(n.p,{children:"Tutti i journal hanno la stessa struttura:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"il Template, Batch e la Register table sono quasi sempre uguali in ogni struttura"}),"\n",(0,o.jsx)(n.li,{children:"la Journal Line e la Ledger Entry invece contengono campi specifici di funzione"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"journal-template",children:"Journal Template"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Journal Template",src:i(92475).A+"",width:"615",height:"348"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Name"}),": Il nome univoco del template. \xc8 possibile definire tanti modelli quanti ne sono necessari, ma di solito un Template per Page ID e uno per Recurring sono sufficienti. Se si desiderano journals con diversi codici di origine, \xe8 necessario avere pi\xf9 modelli."]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Page ID"}),": Per alcune journals, servono pi\xf9 oggetti UI. Per esempio, le General Journals hanno una pagina sia per la banca che per i pagamenti."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Source Code"}),": un codice di traccia per tutte le registrazioni fatte tramite questo template."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reason Code"}),": simile al source code."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recurring"}),": Ogni volta che si registrano righe da un registro ricorrente, vengono create automaticamente nuove righe con una data di registrazione definita nella formula di data ricorrente"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No. Series"}),": il document no. nella journal line viene automaticamente popolato con un nuovo numero da questa serie di numeri"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Vedere esempio pagina ",(0,o.jsx)(n.code,{children:"Def. registrazioni COGE"})]}),"\n",(0,o.jsx)(n.h4,{id:"journal-batch",children:"Journal Batch"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Journal Batch",src:i(70930).A+"",width:"615",height:"232"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Journal Template Name"}),": collegamento al Template"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Name"})," : Codice del Batch"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Description"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reason Code"}),": Se inserito, sovrascrive quello del Template"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No. Series"}),": Se inserito, sovrascrive quello del Template"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"register",children:"Register"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Register",src:i(909).A+"",width:"615",height:"236"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No."}),": Campo automaticamente incrementato per ogni transazione del journal."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"From Entry No."}),": La prima Ledger Entry creata con questa transizione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"To Entry No."}),": L'ultima Ledger Entry creata con questa transizione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Creation Date"}),": Compilata sempre con la data reale di quando \xe8 stata registrata la transizione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"User ID"}),": L'ID dell'utente che ha registrato la transazione"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"journal-line",children:"Journal Line"}),"\n",(0,o.jsx)(n.p,{children:"Le journal line hanno un numero di campi obbligatori che sono richiesti per tutti i journals e alcuni campi che sono richiesti per le sue funzionalit\xe0 di design.\nIl processo di reservation richiede di conoscere il codice del campo da Squash, la data e l'ora della prenotazione. Salveremo anche per quanto tempo vogliono giocare e il codice del giocatore.\nPer la fatturazione abbiamo bisogno del prezzo da fatturare e il costo."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Journal Line",src:i(37668).A+"",width:"615",height:"290"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Journal Template Name"}),": collegamento al Template."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Line No."})," : Ogni Journal ha, virtualmente, un numero illimitato di righe. Questo numero \xe8 automaticamente incrementato di 10000, per poter creare delle righe in mezzo."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Entry Type"}),": Reservation o Invoice."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Document No."}),": Questo numero pu\xf2 essere dato al giocatore come numero della prenotazione. Quando il tipo del movimento \xe8 fattura allora \xe8 il numero della fattura."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Posting Date"}),": \xe8 la data della prenotazione, ma quando il movimento \xe8 fattura allora pu\xf2 essere la data della fattura."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Squash Player No."}),": chi ha fatto la prenorazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Squash Court No."}),": il campo da utilizzare."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Description"}),": aggiornamento automaticamente con il numero del campo, la data e l'ora della prenotazione, pu\xf2 essere modificata dall'utente."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reservation Date"}),": data della prenotazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"From Time"}),": Ora di inizio della prenotazione. Possiamo inserire solo ore intere o mezz'ore."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"To Time"}),": Ora di fine della prenotazione.  Possiamo inserire solo ore intere o mezz'ore. Inserita in automatico quando inseriamo una quantit\xe0."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Quantity"}),": Numero di ore di gioco, possiamo inserire solo unit\xe0 di 0.5, \xe8 calcolata in autoamtico quando i campi time sono inseriti."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unit Cost"}),": Il costo di gestione del campo per un'ora di gioco."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Total Cost"}),": Costo della prenotazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unit Price"}),": Prezzo della fattura per ora per la prenotazione, questo dipende se il giocatore \xe8 un membro del circolo o no."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Total Price"}),": Prezzo totale della fattura per questa prenotazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Applies-to Entry No."}),": Quando una prenotazione \xe8 fatturata, questo campo contiene il numero Squash Entry No. della prenotazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Source Code"}),": Ereditato dalla tabella batch o template e usato in fase di registrazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Chargeable"}),": Quando questa opzione \xe8 usata, non ci sar\xe0 una fattura per questa prenotazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Journal Batch Name"}),": Collegamento al Batch."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reason Code"}),": Ereditato dalla tabella batch o template e usato in fase di registrazione."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Bill-to Customer No."}),": Determina chi paga per la prenotazione. Ereditato dallo Squash Player."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gen. Bus. Posting Group"}),": la combinazione di general business e product posting group determina il Conto COGE (contabilit\xe0 generale) su cui fare il giroconto quando fattureremo la prenotazione. Gen. Bus. Posting Group \xe8 ereditato dal bill-to customer."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gen. Prod. Posting Group"}),": Ereditato dallo squash court."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"External Document No."}),": Quando un giocatore vuole che ci annotiamo un numero di riferimento."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recurring Method"}),": Quando il registro \xe8 un registro ricorrente, \xe8 possibile utilizzare questo campo per determinare se il campo dell'importo viene cancellato dopo la registrazione delle righe."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recurring Frequency"}),": Questo campo determina la nuova data di registrazione dopo che le righe ricorrenti sono state registrate."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Posting No. Series"}),": Quando il template ha un posting no. series, lo si utilizza per popolare questo campo quando si registra."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Prima di partire con il processo di registrazione dobbiamo ancora fare in modo che:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"I campi Time devono essere calcolati per non inserire valori errati"}),"\n",(0,o.jsx)(n.li,{children:"Lo Unit Price deve essere calcolato"}),"\n",(0,o.jsx)(n.li,{children:"I campi Unit Cost, Posting groups, and Bill-to Customer No. devono essere ereditati"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"time-calculation",children:"Time calculation"}),"\n",(0,o.jsx)(n.p,{children:"Vogliamo specificare solo il tempo di inizio e fine. Il campo da squash pu\xf2 essere usato solo in blocchi da 30 minuti. Il campo quantit\xe0 dovrebbe essere calcolato sulla base dei tempi inseriti e vice versa. Per farlo creeremo una nuova tabella con i tempi di inizio e fine permessi. Questa tabella avr\xe0 solo due campi come in figura:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Time calculation",src:i(7921).A+"",width:"615",height:"170"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Time calculation 2",src:i(59528).A+"",width:"640",height:"125"})}),"\n",(0,o.jsx)(n.p,{children:"I campi time nella journal avranno una relazione con la tabella per prevenire che l'utente inserisca valori non permessi.\nOra inseriamo del codice che calcoli la quantit\xe0:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'// campo From Time \ntrigger OnValidate()\nbegin\n    CalcQty;\nend;\n\n// campo To Time \ntrigger OnValidate()\nbegin\n    CalcQty;\nend;\n\nprocedure CalcQty()\nbegin\n    IF ("From Time" <> 0T) AND ("To Time" <> 0T) THEN BEGIN\n        IF "To Time" <= "From Time" THEN\n            FIELDERROR("To Time");\n        ResTime.SETFILTER("Reservation Time", \'>=%1&<%2\', "From Time", "To Time")\n        ResTime.CALCSUMS(Duration);\n        VALIDATE(Quantity, ResTime.Duration);\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.h4,{id:"price-management",children:"Price Management"}),"\n",(0,o.jsx)(n.p,{children:"Questo scenario potrebbe essere pi\xf9 complesso, ma al momento gestiremo solo due campi sulla tabella Squash Court che ci indica il prezzo per i Member e not Member."}),"\n",(0,o.jsx)(n.h4,{id:"inherited-data",children:"Inherited data"}),"\n",(0,o.jsx)(n.p,{children:"Aggiungiamo i seguenti campi presi dalla Resource table alla nostra Squash Court:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Inherited data",src:i(92226).A+"",width:"615",height:"282"})}),"\n",(0,o.jsx)(n.p,{children:'Sono stati aggiunti i campi Unit Code, Unit Price, Gen. Prod. Posting Group, and VAT Prod. Posting Group.\nAdesso nel campo "Squash Court No." della Journal Line andiamo ad inserire il validate:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'// campo Squash Court No. \ntrigger OnValidate()\nbegin\n    IF SquashCourt.GET("Squash Court No.") THEN BEGIN\n        Description := SquashCourt.Description;\n        "Unit Cost" := SquashCourt."Unit Cost";\n        "Gen. Prod. Posting Group" := SquashCourt."Gen. Prod. Posting Group";\n        FindSquashPlayerPrice; // trovare il prezzo\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Gestiamo l'ereditariet\xe0 del campo Bill-to Customer No. dallo squash player e del campo Gen. Bus. Posting Group."}),"\n",(0,o.jsx)(n.h3,{id:"posting-process",children:"Posting process"}),"\n",(0,o.jsx)(n.p,{children:"Ora dobbiamo implementare il posting code, prendendo esempio dalle codeunit delle Resource:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"The posting process",src:i(55883).A+"",width:"613",height:"134"})}),"\n",(0,o.jsxs)(n.p,{children:["La filosofia di Microsoft Business Central \xe8 semplice: ",(0,o.jsx)(n.em,{children:"Test near, Test far, Do-it, Clean up"})]}),"\n",(0,o.jsx)(n.p,{children:"Che significa:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Test near: Dobbiamo testare i campi nella journal line table"}),"\n",(0,o.jsx)(n.li,{children:"Test far: Leggiamo i dati delle tabelle esterne per vedere se tutto \xe8 ok"}),"\n",(0,o.jsx)(n.li,{children:"Do-it: registriamo le righe"}),"\n",(0,o.jsx)(n.li,{children:"Clean up: eliminiamo i dati dalla journal table."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"check-line",children:"Check line"}),"\n",(0,o.jsx)(n.p,{children:"Possiamo vedere chiaramente che i campi nella nostra tabella sono prima controllati e poi c'\xe8 la validazione delle date (e poi ci sarebbe il controllo delle dimensioni)."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'procedure RunCheck()\nbegin\n    WITH SquashJnlLine DO BEGIN\n        IF EmptyLine THEN\n            EXIT;\n        TESTFIELD("Squash Player No.");\n        TESTFIELD("Squash Court No.");\n        TESTFIELD("Posting Date");\n        TESTFIELD("Gen. Prod. Posting Group");\n        TESTFIELD("From Time");\n        TESTFIELD("To Time");\n        TESTFIELD("Reservation Date");\n        TESTFIELD("Bill-to Customer No.");\n        IF "Entry Type" = "Entry Type"::Invoice THEN\n            TESTFIELD("Applies-to Entry No.");\n        IF "Applies-to Entry No." <> 0 THEN\n            TESTFIELD("Entry Type", "Entry Type"::Invoice);\n        IF "Posting Date" <> NORMALDATE("Posting Date") THEN\n            FIELDERROR("Posting Date",Text000);\n        IF (AllowPostingFrom = 0D) AND (AllowPostingTo = 0D) THEN\n            ...\n        END;\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.h4,{id:"post-line",children:"Post line"}),"\n",(0,o.jsx)(n.p,{children:"Il codice del posting \xe8 semplice. I valori sono controllati e poi un record della Register \xe8 creato o aggiornato, infine viene scritta la ledger."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'procedure Code()\nbegin\n    WITH SquashJnlLine DO BEGIN\n        IF EmptyLine THEN\n            EXIT;\n        SquashJnlCheckLine.RunCheck(SquashJnlLine,TempJnlLineDim);\n        IF NextEntryNo = 0 THEN BEGIN\n            SquashLedgEntry.LOCKTABLE;\n            IF SquashLedgEntry.FIND(\'+\') THEN\n                NextEntryNo := SquashLedgEntry."Entry No.";\n            NextEntryNo := NextEntryNo + 1;\n        END;\n        IF SquashReg."No." = 0 THEN BEGIN\n            SquashReg.LOCKTABLE;\n            IF (NOT SquashReg.FIND(\'+\')) OR ... THEN BEGIN\n                SquashReg.INIT;\n                SquashReg."No." := SquashReg."No." + 1;\n                ...\n                SquashReg.INSERT;\n            END;\n        END;\n        SquashReg."To Entry No." := NextEntryNo;\n        SquashReg.MODIFY;\n        SquashPlayer.GET("Squash Player No.");\n        SquashPlayer.TESTFIELD(Blocked,FALSE);\n        IF (GenPostingSetup."Gen. Bus. Posting Group" <> "Gen. Bus. Posting Group") OR\n            (GenPostingSetup."Gen. Prod. Posting Group" <> "Gen. Prod. Posting Group")\n        THEN\n            GenPostingSetup.GET("Gen. Bus. Posting Group", "Gen. Prod. Posting Group");\n        SquashLedgEntry.INIT;\n        SquashLedgEntry."Entry Type" := "Entry Type";\n        SquashLedgEntry."Document No." := "Document No.";\n        ...\n        SquashLedgEntry."No. Series" := "Posting No. Series";\n        SquashLedgEntry.INSERT;\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"processo-di-fatturazione",children:"Processo di fatturazione"}),"\n",(0,o.jsx)(n.p,{children:"L'ultimo step da fare \xe8 il processo di fatturazione. Utilizzeremo il reparto standard delle vendite.\nPer la nostra applicazione dobbiamo crearo il documento di fattura e assicurarci che in fase di registrazione la nostra applicazione di squash venga aggiornata."}),"\n",(0,o.jsx)(n.h3,{id:"fattura",children:"Fattura"}),"\n",(0,o.jsx)(n.p,{children:"Dovremmo creare una funzione che combini le prenotazioni evase in fatture.\nLa funzione dovr\xe0 ciclare tra le Squash ledger entry con entry type reservation e open=yes, ordinate per Open, Entry Type, Bill-To Customer No., Reservation Date e dovr\xe0 creare una fattura per ogni Bill-to Customer No. incontrato.\nPer ogni Squash Ledger Entry creeremo una sales line."}),"\n",(0,o.jsx)(n.h4,{id:"sales-header",children:"Sales Header"}),"\n",(0,o.jsx)(n.p,{children:"The code to create a sales header looks like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'procedure CreateSalesHdr()\nbegin\n    CLEAR(SalesHdr);\n    SalesHdr.SetHideValidationDialog(TRUE);\n    SalesHdr."Document Type" := SalesHdr."Document Type"::Invoice;\n    SalesHdr."Document Date" := WORKDATE;\n    SalesHdr."Posting Date" := WORKDATE;\n    SalesHdr.VALIDATE("Sell-to Customer No.", SquashLedgerEntry."Bill-to Customer No.");\n    SalesHdr.INSERT(TRUE);\n    NextLineNo := 10000;\n    CounterOK := CounterOK + 1;\nend;\n'})}),"\n",(0,o.jsx)(n.h4,{id:"sales-line",children:"Sales Line"}),"\n",(0,o.jsx)(n.p,{children:'Codice per creare una sales line. Da notare che bisogna aggiungere il campo "Applies-to Squash Entry No." alla tabella sales line.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'procedure CreateLn()\nbegin\n    WITH SquashLedgerEntry DO BEGIN\n        GenPstSetup.GET("Gen. Bus. Posting Group", "Gen. Prod. Posting Group");\n        GenPstSetup.TESTFIELD("Sales Account");\n        SalesLn.INIT;\n        SalesLn."Document Type" := SalesHdr."Document Type";\n        SalesLn."Document No." := SalesHdr."No.";\n        SalesLn."Line No." := NextLineNo;\n        SalesLn."System-Created Entry" := TRUE;\n        SalesLn.Type := SalesLn.Type::"G/L Account";\n        SalesLn.VALIDATE("No.", GenPstSetup."Sales Account");\n        SalesLn.Description := Description;\n        SalesLn.VALIDATE(Quantity, Quantity);\n        SalesLn.VALIDATE("Unit Price", "Unit Price");\n        SalesLn.VALIDATE("Unit Cost (LCY)", "Unit Cost");\n        SalesLn."Applies-to Squash Entry No." := "Entry No.";\n        SalesLn.INSERT(TRUE);\n    END;\n    NextLineNo := NextLineNo + 10000;\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Quando aggiungi campi alle tabelle documentali di vendita o acquista, assicurati di aggiungere gli stessi campi anche alle tabelle equialenti registrate, con lo stesso numero di campo. In questo modo l'informazione viene copiata anche nei dati di storico tramite la funzione TRANSFERFIELDS."}),"\n",(0,o.jsx)(n.h4,{id:"dialog",children:"Dialog"}),"\n",(0,o.jsx)(n.p,{children:"Se ci sono molte fatture combinate da creare la funzione potrebbe impiegare molto tempo, potrebbe essere utile mostrare una progress bar all'utente. Business Central ha una struttura standard per farlo.\nIl codice seguente mostra il Bill-to Customer No. che si sta processando e la barra che va da 1 a 100%.\nLo calcoleremo tramite un counter. Alla fine mostriamo un messaggio con il numero delle fatture create e il numero delle Squash Ledger Entry processate."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:"var\n    Progress: Dialog;\n    ProgressMsg: Label 'Creating Invoices for #1######################\\Processing... #2######';\n    Text001: Label 'Created %1 invoices, %2 Squash Entry processed';\nbegin\n    // ...\n    CounterTotal := SquashLedEntry.Count;\n    if SquashLedEntry.Findset() then begin\n        Progress.Open(ProgressMsg);\n        repeat\n            Counter := Counter + 1;\n            Progress.Update(1,\"Bill-to Customer No.\");\n            Progress.Update(2,ROUND(Counter / CounterTotal * 10000, 1));\n            // ...\n        until SquashLedEntry.Next() = 0;\n        Progress.Close();\n    end;\n    Message(Text001,CounterOK,CounterTotal);\nend;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Le costanti label con i valori #N##### consentono di mostrare e aggiornare un testo. Il numero di # danno la dimensione del valore."}),"\n",(0,o.jsx)(n.h3,{id:"posting-process-1",children:"Posting process"}),"\n",(0,o.jsx)(n.p,{children:"Ora siamo pronti per fare le modifiche necessarie al processo di posting della fattura di vendita.\nLa registrazione di un documento di vendita viene fatto usando una singola codeunit di registrazione e altri oggetti di aiuto:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Codeunit 80: La procedura di registrazione che andremo a modificare."}),"\n",(0,o.jsx)(n.li,{children:"Codeunit 81: codeunit chiamata dall'interfaccia utente e ha un dialog se l'utente vuole la spedizione, fattura o entrambe."}),"\n",(0,o.jsx)(n.li,{children:"Codeunit 82: cdu 81 + stampa un report"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Modificheremo la codeunit 80. Vediamo come la codeunit \xe8 strutturata sulla base della strategia: Test Near, Test Far, Do it and Cleanup."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'internal procedure RunWithCheck(var SalesHeader2: Record "Sales Header")\nbegin\n    // ...\n    // Header\n    CheckAndUpdate(SalesHeader);\n\n    ProcessPosting(\n        SalesHeader, SalesHeader2, TempDropShptPostBuffer,\n        TempServiceItem2, TempServiceItemComp2, CustLedgEntry, EverythingInvoiced);\n\n    // ...\n    \n    FinalizePosting(SalesHeader, EverythingInvoiced, TempDropShptPostBuffer); \n    \n    // ...\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"La modifica la faremo collegandoci ad un evento che viene lanciato quando le righe vengono gestite:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'// ...\n// Squash Journal Line\nIF SalesLine."Applies-to Squash Entry No." <> 0 THEN\n    PostSquashJnlLn();\n\nprocedure PostSquashJnlLn()\nbegin\n    WITH SalesHeader DO BEGIN\n        OldSquashLedEnt.GET(SalesLine."Applies-to Squash Entry No.");\n        OldSquashLedEnt.TESTFIELD(Open);\n        OldSquashLedEnt.TESTFIELD("Bill-to Customer No.", "Bill-to Customer No.");\n        \n        SquashJnlLn.INIT;\n        SquashJnlLn."Posting Date" := "Posting Date";\n        SquashJnlLn."Reason Code" := "Reason Code";\n        ...\n        SquashJnlLn."Document No." := GenJnlLineDocNo;\n        SquashJnlLn."External Document No." := GenJnlLineExtDocNo;\n        SquashJnlLn.Quantity := -SalesLine."Qty. to Invoice";\n        SquashJnlLn."Source Code" := SrcCode;\n        SquashJnlLn.Chargeable := TRUE;\n        SquashJnlLn."Posting No. Series" := "Posting No. Series";\n        \n        SquashJnlPostLine.RunWithCheck(SquashJnlLn,TempJnlLineDim);\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"La funzione va a prendere la squash ledger entry collegata, testa se \xe8 ancora aperta e se il Bill-to Customer No. non sia cambiato.\nQuindi popoliamo la Squash Journal con le informazioni corrette e facciamo partire la registrazione.\nDa notare che la journal line non viene inserita nel database in questo processo. Questo viene fatto per ragioni di performance e concorrenza. Neanche i Validate sono stati utilizzati, questo rende molto chiaro capire cosa succede."}),"\n",(0,o.jsxs)(n.p,{children:["Esempio di Squash Entries post registrazione di vendita:\n",(0,o.jsx)(n.img,{alt:"Squash Entries Posted",src:i(37105).A+"",width:"980",height:"125"})]}),"\n",(0,o.jsx)(n.h3,{id:"trova-movimenti",children:"Trova Movimenti"}),"\n",(0,o.jsx)(n.p,{children:"Parte aggiuntiva e opzionale dell'esercizio."}),"\n",(0,o.jsx)(n.p,{children:'La nostra app \xe8 quasi completa, ora potremmo avere la necessita di navigare questi movimenti a partire dalla fattura, per farla dobbiamo integrare la funzione "Trova Movimenti" per trovare anche le nostre Squash Ledger Entry.\nAbbiamo bisogno di agganciarci a due eventi della pagina 344.'}),"\n",(0,o.jsx)(n.h4,{id:"findrecords",children:"FindRecords"}),"\n",(0,o.jsx)(n.p,{children:"La funzione che ricerca nel database trovando tutte le possibili combinazioni di document no. e posting date. Ci collegheremo ad un evento al suo interno."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// Evento\nprocedure OnAfterNavigateFindRecords(var DocumentEntry: Record "Document Entry"; DocNoFilter: Text; PostingDateFilter: Text)\nvar\n    Navigate: Page Navigate;\nbegin \n    IF SquashLedgEntry.READPERMISSION THEN BEGIN\n        SquashLedgEntry.RESET;\n        SquashLedgEntry.SETCURRENTKEY("Document No.", "Posting Date");\n        SquashLedgEntry.SETFILTER("Document No.",DocNoFilter);\n        SquashLedgEntry.SETFILTER("Posting Date",PostingDateFilter);\n        Navigate.InsertIntoDocEntry(DocumentEntry, DATABASE::"Squash Ledger Entry", 0, SquashLedgEntry.TABLECAPTION,SquashLedgEntry.COUNT);\n    END;\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"La funzione controlla se abbiamo i permessi per leggere la Squash Ledger Entry, se non li abbiamo non verr\xe0 mostrata. Il filtraggio viene fatto tramite Document No. e Posting Date. Alla fine viene inserito il risultato di quanti record abbiamo trovato."}),"\n",(0,o.jsx)(n.h4,{id:"showrecords",children:"ShowRecords"}),"\n",(0,o.jsx)(n.p,{children:"La seconda funziona da modificare, viene attivata quando proviamo a navigare i record trovati."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-al",children:'// Evento\nprocedure OnAfterNavigateShowRecords(TableID: Integer; DocNoFilter: Text; PostingDateFilter: Text)\nbegin \n    if TableID = DATABASE::"Squash Ledger Entry" then begin\n        SquashLedgEntry.SETCURRENTKEY("Document No.", "Posting Date");\n        SquashLedgEntry.SETFILTER("Document No.",DocNoFilter);\n        SquashLedgEntry.SETFILTER("Posting Date",PostingDateFilter);\n        Page.Run(0, SquashLedgEntry);\n    end;\nend;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Come risultato finale dobbiamo ottenere:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Navigate",src:i(41852).A+"",width:"426",height:"480"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>t});var a=i(96540);const o={},r=a.createContext(o);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},37105:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-sq-posted-a2f1b39d45dac143fba0282266bc75b9.png"},37668:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-5-cc3bcabe2a33528d23c77d024d993ee1.png"},41852:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-navigate-a78c710cd8b55ac2026054fffefdc042.png"},53042:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-cb400f7a4ac961727725634d612bde13.png"},55883:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-11-32e6a187aac07841ac602135c963e9d3.png"},59528:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-9-e669df093301c4f210ed9361dcb6b57e.png"},69142:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-7-e8ed5cf18dffca2e45e2eef33630782b.png"},70930:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-3-a4e50a0147bb8905b08aeb1489c97e40.png"},92226:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-10-d4b5c760231d208b37dfdf86d54bee88.png"},92475:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-2-4e910312d9776e6b915fb3450e0b0c08.png"},94912:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/bc-posting-image-1-2ecdcecb0c5bdeb65c221403bd658acf.png"}}]);